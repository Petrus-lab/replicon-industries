const express = require("express");
const fs = require("fs");
const { exec } = require("child_process");
const cors = require("cors");
const path = require("path");

const { initializeApp, applicationDefault } = require("firebase-admin/app");
const { getFirestore } = require("firebase-admin/firestore");

const axios = require("axios");
const app = express();
const PORT = 3001;

app.use(cors());
app.use(express.json());
app.use(express.static("ai-interface"));

const helpFile = "operators-manual.md";
const testOutputPath = "test-output.txt";

// Optional Firebase Admin Initialization
let firebaseInitialized = false;
let db = null;
try {
  initializeApp({ credential: applicationDefault() });
  db = getFirestore();
  firebaseInitialized = true;
} catch (err) {
  console.error("Firebase initialization failed:", err.message);
}

app.get("/", (req, res) => {
  res.send("🧠 Local runner ready.");
});

app.post("/run", async (req, res) => {
  const { type, command, code, filename, json, content } = req.body;

  try {
    if (type === "shell") {
      exec(command, (error, stdout, stderr) => {
        if (error) return res.status(500).send(`❌ Shell error: ${error.message}`);
        if (stderr) return res.status(200).send(`⚠️ stderr: ${stderr}`);
        fs.writeFileSync(testOutputPath, stdout);
        return res.send(stdout);
      });

    } else if (type === "python") {
      fs.writeFileSync("temp.py", code);
      exec("python temp.py", (error, stdout, stderr) => {
        if (error) return res.status(500).send(`❌ Python error: ${error.message}`);
        fs.writeFileSync(testOutputPath, stdout || stderr);
        return res.send(stdout || stderr);
      });

    } else if (type === "read") {
      const targetFile = filename || helpFile;
      const contents = fs.readFileSync(path.join(__dirname, targetFile), "utf-8");
      return res.send(contents);

    } else if (type === "write") {
      if (!filename || !content) return res.status(400).send("❌ Filename or content missing.");
      fs.writeFileSync(path.join(__dirname, filename), content);
      return res.send(`✅ Wrote file: ${filename}`);

    } else if (type === "run_json") {
      if (!json || typeof json !== "object") return res.status(400).send("❌ Invalid JSON.");
      const output = JSON.stringify(json, null, 2);
      fs.writeFileSync(testOutputPath, output);
      return res.send(`✅ Parsed JSON:\n${output}`);

    } else {
      return res.status(400).send("❌ Unknown action type.");
    }
  } catch (err) {
    return res.status(500).send(`💥 Server error: ${err.message}`);
  }
});

app.get("/test/firebase", async (req, res) => {
  if (!firebaseInitialized) return res.status(500).send("❌ Firebase not initialized.");
  try {
    const testDoc = db.collection("connectivity").doc("status");
    await testDoc.set({ checkedAt: new Date().toISOString() });
    return res.send("✅ Firebase test passed.");
  } catch (err) {
    return res.status(500).send(`❌ Firebase test failed: ${err.message}`);
  }
});

app.get("/test/github", async (req, res) => {
  try {
    const token = process.env.GITHUB_TOKEN;
    if (!token) return res.status(401).send("❌ GitHub token missing.");
    const { Octokit } = await import("octokit");
    const octokit = new Octokit({ auth: token });
    const response = await octokit.request("GET /user");
    return res.send(`✅ GitHub user: ${response.data.login}`);
  } catch (err) {
    return res.status(500).send(`❌ GitHub test failed: ${err.message}`);
  }
});

app.get("/test/vercel", async (req, res) => {
  try {
    const token = process.env.VERCEL_TOKEN;
    if (!token) return res.status(401).send("❌ Vercel token missing.");
    const response = await axios.get("https://api.vercel.com/v1/user", {
      headers: { Authorization: `Bearer ${token}` },
    });
    return res.send(`✅ Vercel user: ${response.data.user.username || response.data.user.name}`);
  } catch (err) {
    return res.status(500).send(`❌ Vercel test failed: ${err.message}`);
  }
});

app.listen(PORT, () => {
  console.log(`🧠 Replicon Local AI Runner is live on http://localhost:${PORT}`);
});
